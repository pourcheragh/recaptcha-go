/*
reCAPTCHA

reCAPTCHA v3 returns a score for each request without user friction. The score is based on interactions with your site and enables you to take an appropriate action for your site. Register reCAPTCHA v3 keys on the reCAPTCHA Admin console.

API version: 3.0.0
Contact: s.pourcheragh@gmail.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package recaptcha

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// VerifyAPIService VerifyAPI service
type VerifyAPIService service

type ApiSiteVerifyRequest struct {
	ctx context.Context
	ApiService *VerifyAPIService
	secret *string
	response *string
	remoteip *string
}

// The shared key between your site and reCAPTCHA.
func (r ApiSiteVerifyRequest) Secret(secret string) ApiSiteVerifyRequest {
	r.secret = &secret
	return r
}

// The user response token provided by the reCAPTCHA client-side integration on your site.
func (r ApiSiteVerifyRequest) Response(response string) ApiSiteVerifyRequest {
	r.response = &response
	return r
}

// The user&#39;s IP address.
func (r ApiSiteVerifyRequest) Remoteip(remoteip string) ApiSiteVerifyRequest {
	r.remoteip = &remoteip
	return r
}

func (r ApiSiteVerifyRequest) Execute() (*VerifyResponse, *http.Response, error) {
	return r.ApiService.SiteVerifyExecute(r)
}

/*
SiteVerify Verify User Response

Verify a user's response to a reCAPTCHA challenge.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSiteVerifyRequest
*/
func (a *VerifyAPIService) SiteVerify(ctx context.Context) ApiSiteVerifyRequest {
	return ApiSiteVerifyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return VerifyResponse
func (a *VerifyAPIService) SiteVerifyExecute(r ApiSiteVerifyRequest) (*VerifyResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VerifyResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VerifyAPIService.SiteVerify")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/siteverify"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.secret == nil {
		return localVarReturnValue, nil, reportError("secret is required and must be specified")
	}
	if r.response == nil {
		return localVarReturnValue, nil, reportError("response is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "secret", r.secret, "")
	parameterAddToHeaderOrQuery(localVarFormParams, "response", r.response, "")
	if r.remoteip != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "remoteip", r.remoteip, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
